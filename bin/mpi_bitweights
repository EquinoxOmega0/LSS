#!/usr/bin/env python
"""
Compute bit weights in parallel to be used for PIP or IIP weights

Example run at NERSC:

srun -N 16 -c 8 -C haswell -A desi --qos=interactive -t 0:30:0 mpi_bitweights
     --mtl LRG_oneperztrue_clus.dat.fits --randoms LRG_oneperztrue_clus.ran.fits
     --format hdf5 --outdir output --realizations 128

Notes:
- Runs on master version of fiberassign, etc.
- Must add path_to_LSS_repo/LSS/bin to $PATH and path_to_LSS/LSS/py to $PYTHONPATH
- PIP weights are stored as 64 bit integers, so the number of realizations must
  be a multiple of 64 (i.e. 64, 128, 192, etc. realizations correspond to output
  arrays BITWEIGHT0, BITWEIGHT1, BITWEIGHT2, etc.)
- n nodes (-N) x n cpus (-c) must be a factor of the number of realizations

Required Arguments:
  mtl     (str) : target fits file containing TARGETID, RA, DEC, Z
  randoms (str) : randoms fits file containing RA, DEC, Z

Optional Arguments:
  sky          (str) : fits file containing sky targets
  footprint    (str) : fits file containing footprint
  tiles        (str) : text file containing tile IDs
  format       (str) : output file format (fits or hdf5)
  outdir       (str) : output directory
  realizations (int) : number of realizations

Outputs:
  targeted.fits : fits (hdf5) file containing targeted science objects
  parent.fits   : fits (hdf5) file containing parent catalog
  randoms.fits  : fits (hdf5) file containing randoms catalog
"""
import argparse

def parse():
    parser = argparse.ArgumentParser()
    parser.add_argument("--sky", type=str, required=False, help="fits file with sky targets")
    parser.add_argument("--mtl", type=str, required=True,
                        help="fits file with mtl, should contain only targets available to fibers")
    parser.add_argument("--randoms", type=str, required=True, help="fits file with random targets")
    parser.add_argument("--footprint", type=str, required=False, default=None,
                        help="Optional fits file defining the footprint, default footprint from desimodel")
    parser.add_argument("--tiles", type=str, required=False, default=None,
                        help="Optional text file containing a subset of the tile IDs to use in the footprint,"
                        "one ID per line. Default uses all tiles in the footprint.")
    parser.add_argument("--format", type=str, required=False, default="fits",
                        help="File format for outputs (either fits or hdf5)")
    parser.add_argument("--outdir", type=str, required=False, default=".", help="Output directory")
    parser.add_argument("--realizations", type=int, required=False, default=128, help="Number of realizations")

    args = parser.parse_args()
    return args

def main(args):
    # Initialize mpi
    from mpi4py import MPI
    comm = MPI.COMM_WORLD
    mpi_procs = comm.size
    mpi_rank = comm.rank

    import numpy as np
    from LSS.bitweights import (get_tiles, get_targets, setup_fba,
                               update_bitweights, pack_bitweights, write_output)
    from fiberassign.hardware import load_hardware
    from fiberassign.assign import run

    # Get tile information
    tiles = get_tiles(args.tiles, args.footprint)

    # Get target and randoms information
    mtl, tgs, sky, randoms = get_targets(args.mtl, args.sky, args.randoms)
    tg_science = tgs.ids()
    n_target = len(tg_science)

    # Load hardward for fiber assignment
    hw = load_hardware()

    # Divide realizations among processes
    n_realization = args.realizations
    realizations = np.arange(n_realization, dtype=np.int32)
    my_realizations = np.array_split(realizations, mpi_procs)[mpi_rank]

    # Bit weight array for all targets and realizations
    bitweights = np.zeros(n_realization * n_target, dtype=bool)

    for realization in my_realizations:
        # Set the seed based on the realization, so that the result is reproducible
        # regardless of which process is working on the realization
        np.random.seed(realization)

        # Randomize science target subpriority
        mtl['SUBPRIORITY'] = np.random.random_sample(size=n_target)

        # Set up and run fiber assignment
        asgn = setup_fba(mtl, sky, tiles, hw)
        run(asgn)

        # Update bit weights for assigned science targets
        idas, bitweights = update_bitweights(realization, asgn, tiles, tg_science, bitweights)

    # Gather weights from all processes
    gather_weights = None
    if mpi_rank == 0:
        gather_weights = np.empty(len(bitweights), dtype=bool)
    min_targ = np.min(my_realizations) * n_target
    max_targ = (np.max(my_realizations) + 1) * n_target
    comm.Gather(bitweights[min_targ:max_targ], gather_weights, root=0)

    if mpi_rank == 0:
        # Pack weights into 64 bit integers
        weights = np.array_split(gather_weights, n_realization)
        bweights = np.array(weights).T
        bitvectors = pack_bitweights(bweights)

        # Write output files
        write_output('targeted', args.outdir, args.format, mtl[idas], idas, bitvectors)
        write_output('parent', args.outdir, args.format, mtl, idas, bitvectors)
        write_output('randoms', args.outdir, args.format, randoms, idas, bitvectors)

if __name__ == "__main__":
    args = parse()
    main(args)
